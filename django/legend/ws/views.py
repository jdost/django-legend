from django.http import HttpResponse
from legend.journal import models as journal
from legend.gallery import models as gallery
from legend.utils import gallery_tools as tools
from legend import settings
from legend.utils import archiver, View

import json
import hashlib

SALT = 's`\(Xp;xEQ%s}Qc_'


def verify(request):
    '''
    This generates a cookie to authorize that this browser can talk with
    the web services, It is controlled by the VERIFY value held in this
    file, so would require access to this code on the server to allow for
    generating this cookie, should hold indefinitely
    '''
    if request.method != 'POST':
        if isVerified(request):
            return HttpResponse(status=202)
        else:
            return HttpResponse(status=405)
    elif request.method == 'POST' and 'name' not in request.POST:
        return HttpResponse(status=400)

    auth = open(settings.SITE_ROOT + "/ws/AUTH", "r")
    verify = auth.read().strip() == '1'
    name = request.POST['name']
    response = HttpResponse(status=202)
    if verify and 'wsAuth' not in request.COOKIES:
        key_hash = hashlib.sha256(name + SALT).hexdigest()
        response.set_cookie('computer', value=name)
        response.set_cookie('wsAuth', value=key_hash,
            max_age=60 * 60 * 24 * 7)
    else:
        key_hash = hashlib.sha256(name + SALT).hexdigest()
        if request.COOKIES['wsAuth'] == key_hash:
            response.set_cookie('computer', value=name)
        else:
            response.status_code = 401

    return response

BAD_LOGIN = HttpResponse(status=401)


def isVerified(req):
    '''
    This verifies that the cookie generated by the <verify> function exists
    and checks out.
    '''
    return True
    if 'wsAuth' not in req.COOKIES or 'computer' not in req.COOKIES:
        return False
    val = hashlib.sha256(req.COOKIES['computer'] + SALT).hexdigest()
    return val == req.COOKIES['wsAuth']


def format(data):
    '''
    Generic output formatter, currently always outputs a proper JSON document.
    '''
    return HttpResponse(json.dumps(data), mimetype="application/json")


def slugify(base):
    '''
    Simple utility, converts a string into a legal 'slug'.
    '''
    return base.lower().replace(" ", "_").replace(",", "")


def jsonDate(date):
    '''
    Simple utility, converts a <Date> structure into a simple JSON object
    for easier consumption.
    '''
    return {
        "year": date.year,
        "month": date.month,
        "day": date.day,
        "hour": date.hour,
        "minute": date.minute,
        "second": date.second
    }

definitions = {}


def list(request):
    '''
    Simple WS request, just returns a JSON listing of all of the defined
    actions (based on the <definitions> dictionary).
    '''
    if not isVerified(request):
        return BAD_LOGIN
    resp = {
        "base": "/ws",
        "actions": definitions
    }
    return format(resp)

definitions['entry'] = {
    "name": 'entry',
    "command": 'entry'
}


class Entry(View):
    '''
    Overarching class that deals with the <Journal> objects, this handles
    POST, GET, PUT, and DELETE operations on the route, based on URL params.
    '''
    def __call__(self, request, id=None):
        if not isVerified(request):
            return BAD_LOGIN

        if request.method == 'POST':
            return format(self.post(request, id))
        elif request.method == 'GET':
            return format(self.get(request, id))
        elif request.method == 'PUT':
            return format(self.put(request, id))
        elif request.method == 'DELETE':
            return format(self.delete(request, id))

    def get(self, request, id):
        '''
        Handler method for GET operations, if the <id> is not specified, it
        will return a summary array of all of the <Journal> objects in the DB.
        If one is specified, it will return a full definition of that <Journal>
        object.
        '''
        resp = {}
        if id is None:
            resp["entries"] = []
            entry_set = journal.Journal.objects.all().values('title',
                    'date', 'id')
            for entry in entry_set:
                resp["entries"].append({
                    "title": entry["title"],
                    "date": jsonDate(entry["date"]),
                    "id": entry["id"]
                })
        else:
            entry = journal.Journal.objects.get(id=int(id))
            tags = []
            for tag in entry.tags.all():
                tags.append(tag.id)

            resp["entry"] = {
                "title": entry.title,
                "content": entry.content,
                "date": jsonDate(entry.date),
                "id": entry.id,
                "tags": tags
            }
        return resp

    def post(self, request, id):
        '''
        Handler method for POST operations.  If the <id> param is specified,
        it will take the data posted and update the listing for that specific
        <Journal> entry.  If it is not specified, a new entry will be created
        with the data posted.
        '''
        post = request.POST
        if id is None:
            entry = journal.Journal()

            entry.title = post["title"]
            entry.url = slugify(entry.title)
            entry.content = post["content"]
            entry.date = post["date"]

            entry.save()
                # tags too
            tags = json.loads(post["tags"])
            for tag in tags:
                try:
                    tagObj = journal.Tag.objects.get(id=int(tag))
                except ValueError:
                    tagObj = journal.Tag.objects.create(name=tag,
                            url=slugify(tag))
                    tagObj.save()
                entry.tags.add(tagObj)
        else:
            entry = journal.Journal.objects.get(id=int(id))
            if entry.title != post["title"]:
                entry.title = post["title"]
                entry.url = slugify(entry.title)
            if entry.content != post["content"]:
                entry.content = post["content"]

            entry.save()

            tags = json.loads(post["tags"])
            for tag in tags:
                try:
                    tagObj = journal.Tag.objects.get(id=int(tag))
                except ValueError:
                    tagObj = journal.Tag.objects.create(name=tag,
                            url=slugify(tag))
                    tagObj.save()
                entry.tags.add(tagObj)

        return self.get(request, entry.id)

    def put(self, request, id):
        '''
        This is a placeholder, the PUT operation will be used to create a new
        entry, depending on if Django supports the same, nice interface to the
        data that gets posted.
        '''
        return {}

    def delete(self, request, id):
        '''
        Handler method for DELETE operations, only does anything if the <id>
        param is included, it will try to archive the entry and then delete
        it from the database.
        '''
        if id is None:
            return {}
        entry = journal.Journal.objects.get(id=int(id))
        archiver.entry_archive(id)
        entry.delete()
        return {}

definitions['tag'] = {
    "name": 'tag',
    "command": 'tag'
}


class Tag(View):
    '''
    Overarching class that deals with the <Tag> objects, this handles
    POST, GET, and DELETE operations on the route, based on URL params.
    '''
    def __call__(self, request, id=None):
        if not isVerified(request):
            return BAD_LOGIN

        if request.POST:
            return format(self.post(request, id))
        elif request.method == "GET":
            return format(self.get(request, id))
        elif request.method == "DELETE":
            return format(self.delete(request, id))
        else:
            return format({"method": request.method})

    def get(self, request, id):
        '''
        Method that handles GET opertions, if the <id> param is not specified,
        it will return a summary list of all <Tag> objects, if it is specified,
        a full description of the specified <Tag> object will be returned.
        '''
        if id is None:
            resp = {"tags": []}
            tag_set = journal.Tag.objects.all()
            for tag in tag_set:
                resp["tags"].append({
                    "name": tag.name,
                    "id": tag.id,
                    "count": tag.journal_set.count()
                })
        else:
            tag = journal.Tag.objects.get(id=int(id))
            resp = {"tag": {
                    "name": tag.name,
                    "id": tag.id
                },
                "entries": [],
            }
            tagged = tag.journal_set.all().values('id', 'title', 'date')
            entries = journal.Journal.objects.all().values('id',
                    'title', 'date')
            for entry in entries:
                entry["tagged"] = entry in tagged
                entry["date"] = jsonDate(entry["date"])
                resp["entries"].append(entry)

        return resp

    def post(self, request, id):
        '''
        Method that handles POST operations, if the <id> is not specified,
        nothing will happen.  If it is specified, the corresponding <Tag>
        object will get updated based on the POST data.
        '''
        if id is None:
            resp = {}
        else:
            tag = journal.Tag.objects.get(id=int(id))
            additions = json.loads(request.POST["additions"])
            removals = json.loads(request.POST["removals"])
            for entry_id in additions:
                entry = journal.Journal.objects.get(id=int(entry_id))
                entry.tags.add(tag)
            for entry_id in removals:
                entry = journal.Journal.objects.get(id=int(entry_id))
                entry.tags.remove(tag)
            resp = {}
        return resp

    def delete(self, request, id):
        '''
        Method that handles the DELETE operations, if the <id> is not
        specified, nothing happens.  If it is specified, the corresponding
        <Tag> object will get archived and deleted from the DB.
        '''
        if id is None:
            resp = {}
        else:
            tag = journal.Tag.objects.get(id=int(id))
            archiver.tag_archive(id)
            tag.delete()
            resp = {}

        return resp

definitions['album'] = {
}


class Album(View):
    '''
    Overarching class that deals with the <Album> objects, this handles
    POST, GET, DELETE, and FILE operations for the route.
    '''
    def __call__(self, request, id=None):
        if not isVerified(request):
            return BAD_LOGIN

        if request.FILES:  # FILE operation is based on if a file was uploaded
            return format(self.files(request, id))
        if request.method == 'POST':
            return format(self.post(request, id))
        elif request.method == 'GET':
            return format(self.get(request, id))
        elif request.method == 'DELETE':
            return format(self.delete(request, id))

    def get(self, request, id):
        '''
        Method that handles GET operations.  If the <id> param is not
        specified, a summary of all of the <Album> objects will be generated.
        If it is, a full description of the <Album> object will be generated,
        including the full set of associated <Image> objects.
        '''
        if id is None:
            albums = gallery.Album.objects.all()
            album_set = []
            for album in albums:
                album_set.append({
                    "id": album.id,
                    "name": album.name,
                    "description": album.description,
                    "cover": album.get_cover_url()
                })

            return {"album_set": album_set}
        else:
            album = gallery.Album.objects.get(id=int(id))
            return {"album": {
                "id": album.id,
                "name": album.name,
                "description": album.description,
                "cover": album.get_cover_url()
            }}

    def post(self, request, id):
        '''
        Method that handles POST operations.  If the <id> param is not
        specified, a new album is created with the posted data, if it is
        specified, the associated <Album> object will get updated with the
        posted data.
        '''
        post = request.POST

        if id is None:
            album = gallery.Album()
            album.name = post["name"]
            album.description = post["description"]
            album.url = slugify(album.name)
            tools.create_album(album.url)

            album.save()
        else:
            album = gallery.Album.objects.get(id=int(id))
            if "name" in post and album.name != post["name"]:
                album.name = post["name"]
                tools.move_album(album.url, slugify(album.name))
                album.url = slugify(album.name)
            if "description" in post and \
                    album.description != post["description"]:
                album.description = post["description"]
            if "cover" in post and album.cover != post["cover"]:
                album.cover = post["cover"]

            album.save()

            if "images" in post:
                images = json.loads(post["images"])
                for image_data in images:
                    image = gallery.Image.objects.get(id=str(image_data["id"]))
                    image.caption = image_data["caption"]
                    image.save()

        return self.get(request, album.id)

    def delete(self, request, id):
        '''
        Method that handles DELETE operations.  Does nothing if the <id> param
        is not specified, if it is, the <Album> object will be archived and
        deleted from the database.
        '''
        if id is None:
            return {}
        album = gallery.Album.objects.get(id=int(id))
        archiver.album_archive(id)
        # tools.remove_album(album.url)
        album.delete()
        return {}

    def files(self, request, id):
        '''
        Method that handles the file uploads.  Just calls the <handle_images>
        utility function from the gallery toolset.
        '''
        tools.handle_images(request.FILES['images'], id)
        return {}


class Image(View):
    '''
    Overarching class that handles operations for the <Image> object.
    Supports GET, POST, and DELETE operations.
    '''
    def __call__(self, request, id=None):
        if not isVerified(request):
            return BAD_LOGIN

        if id is None:
            return format({})

        if request.POST:
            return format(self.post(request, id))
        elif request.method == "GET":
            return format(self.get(request, id))
        elif request.method == "DELETE":
            return format(self.delete(request, id))

    def get(self, request, id):
        '''
        Method that handles GET operations, just returns the information for
        the specified <Image> object.
        '''
        album = gallery.Album.objects.get(id=str(id))
        images = album.image_set.all()
        image_set = []
        for image in images:
            image_set.append({
                "id": image.id,
                "thumbnail": image.get_thumbnail_url(),
                "url": image.get_static_url(),
                "caption": image.caption
            })

        return {
            "album": {
                "name": album.name
            },
            "images": image_set
        }

    def post(self, request, id):
        '''
        Method that handles POST operations, really just updates the caption
        of the specified <Image> object.
        '''
        post = request.POST

        image = gallery.Image.objects.get(id=str(id))
        image.caption = post["caption"]
        image.save()

        return {}

    def delete(self, request, id):
        '''
        Method that handles the DELETE operations, it will archive the <Image>
        object and then remove it from the database.
        '''
        image = gallery.Image.objects.get(id=str(id))
        archiver.image_archive(id)
        image.delete()
        return {}
